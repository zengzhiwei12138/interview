### 数据库方面

> 索引

- 索引的效率取决于索引列的值是否散列   即该列的值如果互不相同  那么索引效率越高    反之  如果记录的列存在大量相同的值  例如性别   因此对性别gender创建索引就没有意义
- 索引的优点是提高了查询效率    缺点是在插入/更新/删除记录时 需要同时修改索引   因此  索引越多   插入/更新/删除记录的速度就越慢
- 对于主键  关系数据库会自动对其创建主键索引   使用主键索引的效率是最高的   因为主键是绝对唯一

> 索引的选取原则

1，**最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询`（>,<,BETWEEN,LIKE）`就停止匹配。

2，尽量选择**区分度高的列作为索引**，区分度的公式是 `COUNT(DISTINCT col) / COUNT(*)`。表示字段不重复的比率，比率越大我们扫描的记录数就越少。

3，**索引列不能参与计算，尽量保持列“干净”**。比如，`FROM_UNIXTIME(create_time) = '2016-06-06'` 就不能使用索引，原因很简单，**B+树中存储的都是数据表中的字段值**，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： `create_time = UNIX_TIMESTAMP('2016-06-06')`。

4，尽可能的**扩展索引**，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。



> 事务隔离级别

- READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

> 悲观锁和乐观锁

**乐观锁和悲观锁是两种思想**

- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

乐观锁的实现方式主要有两种  CAS机制和版本号控制

优缺点

- 与悲观锁相比，乐观锁适用的场景受到了更多的限制，无论是CAS还是版本号机制  CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS是无能为力的
- 如果悲观锁和乐观锁都可以使用，那么选择就要考虑竞争的激烈程度  
  - 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
  - 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源

> ACID

- atomicity 原子性   事务是不可分割的最小的执行单元 事务的原子性确保所有操作要么全部被提交  要么全部回滚
- consistency 一致性   多个事务对同一个数据读取的结果是相同的
- isolation 隔离性   事务执行过程中 不受其他事务影响  各事务之间的操作是独立的
- durability  持久性  一旦事务提交 它对数据库的改变是持久的   即使系统发生崩溃 事务的执行结果也不会丢失   

> 面试官: 乐观锁加锁吗?

- 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子。
- 有时乐观锁可能与加锁操作合作，例如，在MySQL执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。

> CAS 有哪些缺点

- ABA 问题
- 高竞争下CPU开销问题
- 功能限制  CAS只能保证单个变量（或者说单个内存值）操作的原子性

### 网络协议方面

> 浏览器输入URL发生了什么  TCP和UDP的区别   TCP如何保证传输可靠性







### JVM方面

> java 内存模型

> 常见的垃圾回收器

> 双亲委派模型



### 操作系统的内存管理机制





### 线程方面

> 进程和线程的区别

> 谈谈对线程安全的理解

> volatile 有什么作用

> synchronized 和 lock 有什么区别

> ReentrantLock 实现原理

> CountDownLatch 

> AQS 底层原理

> 造成死锁的原因有哪些  如何预防

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**破坏请求与保持条件**

一次性申请所有的资源。

**破坏不剥夺条件**

占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

**破坏循环等待条件**

靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

> 加锁会带来什么性能问题  如何解决

> 1. HashMap、ConcurrentHashMap源码。HashMap是线程安全的吗？Hashtable呢？ConcurrentHashMap有了解吗？



> 常见的排序算法 及其复杂度   